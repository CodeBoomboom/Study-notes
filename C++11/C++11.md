# 1. auto关键字

1、auto 在 C++11 中只是“占位符”，并非如 int 一样的真正的类型声明

2、

```C++
int n = 20;
auto *p = &n, m = 99;
```

推导的时候不能有二义性。在本例中，编译器根据第一个子表达式已经推导出 auto 为 int 类型，那么后面的 m 也只能是 int 类型，如果写作`m=12.5`就是错误的，因为 12.5 是double 类型，这和 int 是冲突的。

3、使用 auto 类型推导的变量必须马上初始化（auto只是占位符）

4、aut可以随意推导为任意的类型

```C++
int  x = 0;
auto *p1 = &x;   //p1 为 int *，auto 推导为 int
auto  p2 = &x;   //p2 为 int*，auto 推导为 int*
auto &r1  = x;   //r1 为 int&，auto 推导为 int
auto r2 = r1;    //r2 为  int，auto 推导为 int
```

5、auto推导为const类型时const属性会被抛弃，但是当其与引用结合时则不会抛弃const属性

```C++
int  x = 0;
const  auto n = x;  //n 为 const int ，auto 被推导为 int
auto f = n;      //f 为 const int，auto 被推导为 int（const 属性被抛弃）
const auto &r1 = x;  //r1 为 const int& 类型，auto 被推导为 int
auto &r2 = r1;  //r1 为 const int& 类型，auto 被推导为 const int 类型
```

6、auto 不能在函数的参数中使用。

​	这个应该很容易理解，我们在定义函数的时候只是对参数进行了声明，指明了参数的类型，但并没有给它赋值，只有在实际调用函数的时候才会给参数赋值；而 auto 要求必须对变量进行初始化，所以这是矛盾的。

7、auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中。

8、auto 关键字不能定义数组，比如下面的例子就是错误的：

```C++
char url[] = "http://c.biancheng.net/";
auto  str[] = url;  //url为数组，所以不能使用 auto
```

9、auto 不能作用于模板参数，请看下面的例子：

```c++
template <typename T>
class A{
    //TODO:
};
int  main(){
    A<int> C1;
    A<auto> C2 = C1;  //错误
    return 0;
}
```

10、auto应用

（1）用于定义迭代器（迭代器名字太长）

注意：在STL的函数中使用auto类型时候要加*，如

```C++
set<int> myset;
for(auto i = 0; i<myset.size(); i++)
{
	if(myset.count(*i) == 1) break;	
}
```

（2）用于泛型编程

​	使用模板函数进行编程时若调用了其他不同类的同名函数，因为不知道函数返回的值的类型，先用auto接收，这样就避免了再使用一个模板函数参数。



# 2. decltype关键字

1、auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：

```c++
auto varname = value;
decltype(exp) varname = value;//varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式
decltype(exp) varname;//decltype也可以写成这样
```

auto 根据`=`右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟`=`右边的 value 没有关系；

auto 要求变量必须初始化，而 decltype 不要求，这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了；

exp 是一个表达式，可以是任意复杂的形式，但它的结果必须是有类型的，不能是 void，否则会导致编译错误；

delctype用法示例：

```c++
int a = 0;

decltype(a) b = 1;  //b 被推导成了 int

decltype(10.8) x = 5.5;  //x 被推导成了 double

decltype(x + 100) y;  //y 被推导成了 double
```

2、exp

- 如果 exp 是一个不被括号`( )`包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。

- 如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。

- 如果 exp 是一个左值，或者被括号`( )`包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&

  左值和右值：左值是指那些**在表达式执行结束后依然存在的数据**，也就是持久性的数据；右值是指那些在表达式**执行结束后不再存在的数据**，也就是临时性的数据。有一种很简单的方法来区分左值和右值，**对表达式取地址，如果编译器不报错就为左值，否则为右值**。

```C++
//exp内为一般表达式
#include <string>
using namespace std;

class Student{
public:
    static int total;
    string name;
    int age;
    float scores;
};

int Student::total = 0;

int  main(){
    int n = 0;
    const int &r = n;
    Student stu;

    decltype(n) a = n;  //n 为 int 类型，a 被推导为 int 类型
    decltype(r) b = n;     //r 为 const int& 类型, b 被推导为 const int& 类型
    decltype(Student::total) c = 0;  //total 为类 Student 的一个 int 类型的成员变量，c 被推导为 int 类型
    decltype(stu.name) url = "http://c.biancheng.net/cplus/";  //total 为类 Student 的一个 string 类型的成员变量， url 被推导为 string 类型

    return 0;
}
```

```c++
//exp内为函数调用，exp 中调用函数时需要带上括号和参数，但这仅仅是形式，并不会真的去执行函数代码。
//函数声明
int& func_int_r(int, char);  //返回值为 int&
int&& func_int_rr(void);  //返回值为 int&&
int func_int(double);  //返回值为 int

const int& fun_cint_r(int, int, int);  //返回值为 const int&
const int&& func_cint_rr(void);  //返回值为 const int&&

//decltype类型推导
int n = 100;
decltype(func_int_r(100, 'A')) a = n;  //a 的类型为 int&
decltype(func_int_rr()) b = 0;  //b 的类型为 int&&
decltype(func_int(10.5)) c = 0;   //c 的类型为 int

decltype(fun_cint_r(1,2,3))  x = n;    //x 的类型为 const int &
decltype(func_cint_rr()) y = 0;  // y 的类型为 const int&&
```

```c++
//exp为左值或被()包围
using namespace std;

class Base{
public:
    int x;
};

int main(){
    const Base obj;

    //带有括号的表达式
    decltype(obj.x) a = 0;  //obj.x 为类的成员访问表达式，符合推导规则一，a 的类型为 int
    decltype((obj.x)) b = a;  //obj.x 带有括号，符合推导规则三，b 的类型为 int&。

    //加法表达式
    int n = 0, m = 0;
    decltype(n + m) c = 0;  //n+m 得到一个右值，符合推导规则一，所以推导结果为 int
    decltype(n = n + m) d = c;  //n=n+m 得到一个左值，符号推导规则三，所以推导结果为 int&

    return 0;
}
```

3、delctype应用

推导类的非静态成员的类型

# 3. auto与decltype的区别

1、语法格式区别

语法区别详见前两节

- auto 根据`=`右边的初始值 value 推导出变量的类型；
- decltype 根据 exp 表达式推导出变量的类型，跟`=`右边的 value 没有关系。
- auto 要求变量必须初始化，也就是在定义变量的同时必须给它赋值；而 decltype 不要求，初始化与否都不影响变量的类型。这很容易理解，因为 auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。
- auto 将变量的类型和初始值绑定在一起，而 decltype 将变量的类型和初始值分开；虽然 auto 的书写更加简洁，但 decltype 的使用更加灵活。

2、对cv限定符的处理

「cv 限定符」是 const 和 volatile 关键字的统称：

- const 关键字用来表示数据是只读的，也就是不能被修改；
- volatile 和 const 是相反的，它用来表示数据是可变的、易变的，目的是不让 CPU 将数据缓存到寄存器，而是从原始的内存中读取（这点在嵌入式C++编程中尤为常见，在嵌入式编程中有些寄存器的值的改变不能被忽略）。

在推导变量类型时，auto 和 decltype 对 cv 限制符的处理是不一样的。**decltype 会保留 cv 限定符，而 auto 有可能会去掉 cv 限定符**。

以下是 auto 关键字对 cv 限定符的推导规则：

- 如果表达式的类型不是指针或者引用，auto 会把 cv 限定符直接抛弃，推导成 non-const 或者 non-volatile 类型。
- 如果表达式的类型是指针或者引用，auto 将保留 cv 限定符

3、对引用的处理

decltype 会保留引用类型，而 auto 会抛弃引用类型，直接推导出它的原始类型。



# 4. C++返回值类型后置（跟踪返回值类型）

在泛型编程中，可能需要通过参数的运算来得到返回值的类型。C++返回值类型后置（跟踪返回值类型）语法就是将 decltype 和 auto 结合起来完成返回值类型的推导的。

```C++
//不使用C++返回值类型后置（跟踪返回值类型）语法template <typename R, typename T, typename U>R add(T t, U u){    return t+u;}int a = 1; float b = 2.0;auto c = add<decltype(a + b)>(a, b);
```

```C++
//使用C++返回值类型后置（跟踪返回值类型）语法template <typename T, typename U>auto add(T t, U u) -> decltype(t + u){    return t + u;}
```

```c++
//使用C++返回值类型后置（跟踪返回值类型）语法//函数声明int& foo(int& i);	//foo没有具体意思，一般用作一个变量或函数的代号float foo(float& f);template <typename T>auto func(T& val) -> decltype(foo(val)){    return foo(val);}
```

返回值类型后置语法，是为了解决函数返回值类型依赖于参数而导致难以确定返回值类型的问题。





# 5. C++11对模板实例化中连续右尖括号>>的改进

在 C++98/03 的泛型编程中，模板实例化有一个很烦琐的地方，那就是连续两个右尖括号（>>）会被编译器解释成右移操作符，而不是模板参数表的结束（必须在两个右尖括号中间加个空格）。

```C++
//如以下代码会报错:error: '>>' should be '>>' within a nested template argument list Foo<A<int>>::type xx;template <typename T>struct Foo{      typedef T type;};template <typename T>class A{    // ...};int main(void){    Foo<A<int>>::type xx;  //编译出错    return 0;}
```

在 C++11 标准中，要求编译器对模板的右尖括号做单独处理，使编译器能够正确判断出`>>`是一个右移操作符还是模板参数表的结束标记（delimiter，界定符）。但是使用这个代码还是会有问题`Foo<100 >> 2> xx;`，应该加括号`Foo<(100 >> 2)> xx;`

# 6. C++11使用using定义别名（替代typedef）

在C++中可以通过 typedef 重定义一个类型：

```c++
typedef unsigned int uint_t;
```

被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字。因此，下面这样将不是合法的函数重载：

```c++
void func(unsigned int);void func(uint_t); // error: redefinition
```

使用 typedef 重定义类型是很方便的，但它也有一些限制，比如，无法重定义一个模板。

想象下面这个场景：

```c++
typedef std::map<std::string, int> map_int_t;// ...typedef std::map<std::string, std::string> map_str_t;// ...
```

我们需要的其实是一个固定以 std::string 为 key 的 map，它可以映射到 int 或另一个 std::string。然而这个简单的需求仅通过 typedef 却很难办到。

因此，在 C++98/03 中往往不得不这样写：

```C++
template <typename Val>struct str_map{    	typedef std::map<std::string, Val> type;};// ...str_map<int>::type map1;// ...
```

一个虽然简单但却略显烦琐的 str_map 外敷类是必要的。这明显让我们在复用某些泛型代码时非常难受。

**现在，在 C++11 中终于出现了可以重定义一个模板的语法**。请看下面的示例：

```C++
template <typename Val>using str_map_t = std::map<std::string, Val>;// ...str_map_t<int> map1;
```

这里使用新的 using 别名语法定义了 std::map 的模板别名 str_map_t。比起前面使用外敷模板加 typedef 构建的 str_map，它完全就像是一个新的 map 类模板，因此，简洁了很多。

实际上，using 的别名语法覆盖了 typedef 的全部功能。先来看看对普通类型的重定义示例，将这两种语法对比一下：

```C++
// 重定义unsigned inttypedef unsigned int uint_t;using uint_t = unsigned int;// 重定义std::maptypedef std::map<std::string, int> map_int_t;using map_int_t = std::map<std::string, int>;
```

typedef 的定义方法和变量的声明类似：像声明一个变量一样，声明一个重定义类型，之后在声明之前加上 typedef 即可。这种写法凸显了 C/C++ 中的语法一致性，但有时却会增加代码的阅读难度。比如重定义一个函数指针时：

```C++
typedef void (*func_t)(int, int);
```

与之相比，using 后面总是立即跟随新标识符（Identifier），之后使用类似赋值的语法，把现有的类型（type-id）赋给新类型：

```c++
using func_t = void (*)(int, int);
```

从上面的对比中可以发现，C++11 的 using 别名语法比 typedef 更加清晰。因为 typedef 的别名语法本质上类似一种解方程的思路。而 using 语法通过赋值来定义别名，和我们平时的思考方式一致。

下面再通过一个对比示例，看看**新的 using 语法是如何定义模板别名的**。

```C++
/* C++98/03 */template <typename T>struct func_t{    typedef void (*type)(T, T);};// 使用 func_t 模板func_t<int>::type xx_1;/* C++11 */template <typename T>using func_t = void (*)(T, T);// 使用 func_t 模板func_t<int> xx_2;
```

从示例中可以看出，通过 using 定义模板别名的语法，只是在普通类型别名语法的基础上增加 template 的参数列表。使用 using 可以轻松地创建一个新的模板别名，而不需要像 C++98/03 那样使用烦琐的外敷模板。

需要注意的是，using 语法和 typedef 一样，并不会创造新的类型。也就是说，上面示例中 C++11 的 using 写法只是 typedef 的等价物。虽然 using 重定义的 func_t 是一个模板，但 func_t<int> 定义的 xx_2 并不是一个由类模板实例化后的类，而是 void(*)(int, int) 的别名。

因此，下面这样写：

```C++
void foo(void (*func_call)(int, int));void foo(func_t<int> func_call); // error: redefinition
```

同样是无法实现重载的，func_t<int>只是 void(*)(int, int) 类型的等价物。

using 重定义的 func_t 是一个模板，但它既不是类模板也不是函数模板（函数模板实例化后是一个函数），而是一种新的模板形式：**模板别名（alias template）**。

# 7. C++11支持函数模板的默认模板参数

在 [C++](http://c.biancheng.net/cplus/)98/03 标准中，类模板可以有默认的模板参数，如下：

```c++
template <typename T, typename U = int, U N = 0>struct Foo{	// ...};
```

但是却不支持函数的默认模板参数：

```c++
template <typename T = int>// error in C++98/03: default template argumentsvoid func(){    	// ...}
```

现在这一限制在 C++11 中被解除了。上面的 func 函数在 C++11 中可以直接使用，代码如下：

```c++
int main(void){    	func(); //T = int    	return 0;}
```

此时模板参数 T 的类型就为默认值 int。从上面的例子中可以看出，当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随`<>`来实例化。

函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数表最后的限制。甚至于，根据实际场景中函数模板被调用的情形，编译器还可以自行推导出部分模板参数的类型。

这意味着，当默认模板参数和编译器自行推导出模板参数类型的能力一起结合使用时，代码的书写将变得异常灵活。我们可以指定函数中的一部分模板参数采用默认参数，而另一部分使用自动推导，比如下面的例子：

```c++
template <typename R = int, typename U>		//R使用默认模板参数，U使用自动推导R func(U val){    return val;}int main(){    func(97);               // R=int, U=int，编译器可以根据实参 97 自行推导出模板参数 U 的类型为 int，并且根据返回值 val=97 推导出 R 的类型也为 int    func<char>(97);         // R=char, U=int，手动指定了模板参数 R 的类型为 char（默认模板参数将无效），并通过实参 97 推导出了 U = int    func<double, int>(97);  // R=double, U=int，  func<double,int>(97) 手动指定的 R 和 U 的类型值，因此无需编译器自行推导    return 0;}
```

**当默认模板参数和自行推导的模板参数同时使用时，若无法推导出函数模板参数的类型，编译器会选择使用默认模板参数；如果模板参数即无法推导出来，又未设置其默认值，则编译器直接报错**。





# 8. C++11在函数模板和类模板中使用可变参数

## 可变参数

**可变参数**：参数的个数和类型都可以是任意的。如printf()中的参数就是可变参数，可以接收任意个参数且参数类型可以不同，例： `printf("%d %c %f",10, 'A', 1.23);`。

通常将容纳多个参数的可变参数称为**参数包**。借助 format 字符串，printf() 函数可以轻松判断出参数包中的参数个数和类型。

下面的程序中，自定义了一个简单的可变参数函数：

```c++
#include <iostream>#include <cstdarg>//可变参数的函数void vair_fun(int count, ...)	//...就是参数包{    va_list args;    va_start(args, count);    for (int i = 0; i < count; ++i)    {        int arg = va_arg(args, int);        std::cout << arg << " ";    }    va_end(args);}int main(){    //可变参数有 4 个，分别为 10、20、30、40    vair_fun(4, 10, 20, 30,40);    return 0;}
```

程序中的 vair_fun() 函数有 2 个参数，一个是 count，另一个就是 ... 可变参数。我们可以很容易在函数内部使用 count 参数，但要想使用参数包中的参数，需要借助`<cstdarg>`头文件中的 va_start、va_arg 以及 va_end 这 3 个带参数的宏：

- va_start(args, count)：args 是 va_list 类型的变量，我们可以简单的将其视为 char * 类型。借助 count 参数，找到可变参数的起始位置并赋值给 args；
- va_arg(args, int)：调用 va_start 找到可变参数起始位置的前提下，通过指明参数类型为 int，va_arg 就可以将可变参数中的第一个参数返回；
- va_end(args)：不再使用 args 变量后，应及时调用 va_end 宏清理 args 变量。

注意，借助 va_arg 获取参数包中的参数时，va_arg 不具备自行终止的能力，所以程序中借助 count 参数控制 va_arg 的执行次数，继而将所有的参数读取出来。控制 va_arg 执行次数还有其他方法，比如读取到指定数据时终止。

使用 ... 可变参数的过程中，需注意以下几点：

1. ... 可变参数必须作为函数的最后一个参数，且一个函数最多只能拥有 1 个可变参数。
2. 可变参数的前面至少要有 1 个有名参数（例如上面例子中的 count 参数）；
3. 当可变参数中包含 char 类型的参数时，va_arg 宏要以 int 类型的方式读取；当可变参数中包含 short 类型的参数时，va_arg 宏要以 double 类型的方式读取。

## 可变参数模板

C++ 11 标准发布之前，函数模板和类模板只能设定固定数量的模板参数。C++11 标准对模板的功能进行了扩展，允许模板中包含任意数量的模板参数，这样的模板又称可变参数模板。

### 1）可变参数函数模板

```c++
template<typename... T>void vair_fun(T...args) {    //函数体}
```

模板参数中， **typename（或者 class）后跟 ... 就表明 T 是一个可变模板参数**，它可以接收多种数据类型，又称模板参数包。**vair_fun() 函数中，args 参数的类型用 T... 表示，表示 args 参数可以接收任意个参数，又称函数参数包。**

这也就意味着，此函数模板最终实例化出的 vair_fun() 函数可以指定任意类型、任意数量的参数。例如，我们可以这样使用这个函数模板：

```c++
vair_fun();vair_fun(1, "abc");vair_fun(1, "abc", 1.23);
```

使用可变参数模板的难点在于，如何在模板函数内部“解开”参数包（使用包内的数据）。

【递归方式解包】

```c++
#include <iostream>using namespace std;//模板函数递归的出口void vir_fun() {}template <typename T, typename... args>void vir_fun(T argc, args... argv){    cout << argc << endl;    //开始递归，将第一个参数外的 argv 参数包重新传递给 vir_fun    vir_fun(argv...);}int main(){    vir_fun(1, "xiaodexin", 2.34);    return 0;}
```

执行结果：

```
1xiaodexin2.34
```

- 首先，main() 函数调用 vir_fun() 模板函数时，根据所传实参的值，可以很轻易地判断出模板参数 T 的类型为 int，函数参数 argc 的值为 1，剩余的模板参数和函数参数都分别位于 args 和 argv 中；
- vir_fun() 函数中，首先输出了 argc 的值（为 1），然后重复调用自身，同时将函数参数包 argv 中的数据作为实参传递给形参 argc 和 argv（此时传给argc的为“xiaodexin”，传给argv的是2.34）；
- 再次执行 vir_fun() 函数，此时模板参数 T 的类型为 char*，输出 argc 的值为 "xiaodexin"。再次调用自身，继续将 argv 包中的数据作为实参（此时传给argc的为2.34，传给argv的为空）；
- 再次执行 vir_fun() 函数，此时模板参数 T 的类型为 double，输出 argc 的值为 2.34。再次调用自身，将空的 argv 包作为实参；
- 由于 argv 包没有数据，此时会调用无任何形参、函数体为空的 vir_fun() 函数，最终执行结束。

**以递归方式解包，一定要设置递归结束的出口。例如本例中，无形参、函数体为空的 vir_fun() 函数就是递归结束的出口。**

【非递归方法解包】
借助逗号表达式和初始化列表，也可以解开参数包。

以 vir_fun() 函数为例，下面程序演示了非递归方法解包的过程：

```C++
#include <iostream>using namespace std;template <typename T>void dispaly(T t) {    cout << t << endl;}template <typename... args>void vir_fun(args... argv){    //逗号表达式+初始化列表    int arr[] = { (dispaly(argv),0)... };}int main(){    vir_fun(1, "http://www.biancheng.net", 2.34);    return 0;}
```

这里重点分析一下第 13 行代码，我们以`{ }`初始化列表的方式对数组 arr 进行了初始化， (display(argv),0)... 会依次展开为 (display(1),0)、(display("http://www.biancheng.net"),0) 和 (display(2.34),0)。也就是说，第 13 行代码和如下代码是等价的：

```C++
int arr[] = { (dispaly(1),0), (dispaly("http://www.biancheng.net"),0),(dispaly(2.34),0) };
```

可以看到，每个元素都是一个逗号表达式，以 (display(1), 0) 为例，它会先计算 display(1)，然后将 0 作为整个表达式的值返回给数组，因此 arr 数组最终存储的都是 0。arr 数组纯粹是为了将参数包展开，没有发挥其它作用。

### 2）可变参数类模板

C++11 标准中，类模板中的模板参数也可以是一个可变参数。C++ 11 标准提供的 typle 元组类就是一个典型的可变参数模板类，它的定义如下：

```c++
template <typename... Types>class tuple;
```

和固定模板参数的类不同，typle 模板类实例化时，可以接收任意数量、任意类型的模板参数，例如：

```c++
std:tuple<> tp0;std::tuple<int> tp1 = std::make_tuple(1);std::tuple<int, double> tp2 = std::make_tuple(1, 2.34);std::tuple<int, double, string> tp3 = std::make_tuple(1, 2.34, "http://www.biancheng.net");
```

如下是一个支持可变参数的类模板：

```c++
#include <iostream>//声明模板类demotemplate<typename... Values> class demo;//继承式递归的出口template<> class demo<> {};//以继承的方式解包template<typename Head, typename... Tail>class demo<Head, Tail...>    : private demo<Tail...>{public:    demo(Head v, Tail... vtail) : m_head(v), demo<Tail...>(vtail...) {        dis_head();    }    void dis_head() { std::cout << m_head << std::endl; }protected:    Head m_head;};int main() {    demo<int, float, std::string> t(1, 2.34, "xiaodexin");    return 0;}
```

程序的输出结果为：

```
xiaodeixn2.341
```

程序中，demo 模板参数中的 Tail 就是一个参数包，解包的方式是以“递归+继承”的方式实现的。具体来讲，demo<Head, Tail...> 类实例化时，由于其继承自 demo<Tail...> 类，因此父类也会实例化，一直递归至 Tail 参数包为空，此时会调用模板参数列表为空的 demo 模板类。





# 9. C++11 tuple元组

C++11引入了一种类模板tuple，最大的特点：实例化的对象可以存储任意数量、任意类型的数据。

例如当需要存储多个不同类型的元素时，可以使用 tuple；当函数需要返回多个数据时，可以将这些数据存储在 tuple 中，函数只需返回一个 tuple 对象即可。

## tuple的创建

tuple 本质是一个以可变模板参数定义的类模板，它定义在 <tuple> 头文件并位于 std 命名空间中。因此要想使用 tuple 类模板，程序中需要首先引入以下代码：

```c++
#include <tuple>using std::tuple;
```

实例化 tuple 模板类对象常用的方法有两种，一种是借助该类的构造函数，另一种是借助 make_tuple() 函数。

### 1）构造函数

```
1) 默认构造函数constexpr tuple();2) 拷贝构造函数tuple (const tuple& tpl);3) 移动构造函数tuple (tuple&& tpl);4) 隐式类型转换构造函数template <class... UTypes>    tuple (const tuple<UTypes...>& tpl); //左值方式template <class... UTypes>    tuple (tuple<UTypes...>&& tpl);      //右值方式5) 支持初始化列表的构造函数explicit tuple (const Types&... elems);  //左值方式template <class... UTypes>    explicit tuple (UTypes&&... elems);  //右值方式6) 将pair对象转换为tuple对象template <class U1, class U2>    tuple (const pair<U1,U2>& pr);       //左值方式template <class U1, class U2>    tuple (pair<U1,U2>&& pr);            //右值方式
```

举例：

```c++
#include <iostream>     // std::cout#include <tuple>        // std::tupleusing std::tuple;int main(){    std::tuple<int, char> first;                             // 1)   first{}    std::tuple<int, char> second(first);                     // 2)   second{}    std::tuple<int, char> third(std::make_tuple(20, 'b'));   // 3)   third{20,'b'}    std::tuple<long, char> fourth(third);                    // 4)的左值方式, fourth{20,'b'}    std::tuple<int, char> fifth(10, 'a');                    // 5)的右值方式, fifth{10.'a'}    std::tuple<int, char> sixth(std::make_pair(30, 'c'));    // 6)的右值方式, sixth{30,''c}    return 0;}
```



### 2）make_tuple函数

上面程序中，我们已经用到了 make_tuple() 函数，它以模板的形式定义在 <tuple> 头文件中，功能是创建一个 tuple 右值对象（或者临时对象）。

对于 make_tuple() 函数创建了 tuple 对象，我们可以上面程序中那样作为移动构造函数的参数，也可以这样用：

```c++
auto first = std::make_tuple (10,'a');   // tuple < int, char >const int a = 0; int b[3];auto second = std::make_tuple (a,b);     // tuple < int, int* >
```

程序中分别创建了 first 和 second 两个 tuple 对象，它们的类型可以直接用 auto 表示。

## tuple常用函数

| 函数或类模板                     | 描 述                                                        |
| -------------------------------- | ------------------------------------------------------------ |
| tup1.swap(tup2) swap(tup1, tup2) | tup1 和 tup2 表示类型相同的两个 tuple 对象，tuple 模板类中定义有一个 swap() 成员函数，<tuple> 头文件还提供了一个同名的 swap() 全局函数。  swap() 函数的功能是交换两个 tuple 对象存储的内容。 |
| get<num>(tup)                    | tup 表示某个 tuple 对象，num 是一个整数，get() 是 <tuple> 头文件提供的全局函数，功能是返回 tup 对象中第 num+1 个元素。 |
| tuple_size<type>::value          | tuple_size 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 value，功能是获取某个 tuple 对象中元素的个数，type 为该tuple 对象的类型。 |
| tuple_element<I, type>::type     | tuple_element 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 type，功能是获取某个 tuple 对象第 I+1 个元素的类型。 |
| forward_as_tuple<args...>        | args... 表示 tuple 对象存储的多个元素，该函数的功能是创建一个 tuple 对象，内部存储的 args... 元素都是右值引用形式的。 |
| tie(args...) = tup               | tup 表示某个 tuple 对象，tie() 是 <tuple> 头文件提供的，功能是将 tup 内存储的元素逐一赋值给 args... 指定的左值变量。 |
| tuple_cat(args...)               | args... 表示多个 tuple 对象，该函数是 <tuple> 头文件提供的，功能是创建一个 tuple 对象，此对象包含 args... 指定的所有 tuple 对象内的元素。 |

tuple 模板类对赋值运算符 = 进行了重载，使得同类型的 tuple 对象可以直接赋值。此外，tuple 模板类还重载了 ==、!=、<、>、>=、<= 这几个比较运算符，同类型的 tuple 对象可以相互比较（逐个比较各个元素）。

```c++
#include <iostream>#include <tuple>int main(){    int size;    //创建一个 tuple 对象存储 10 和 'x'    std::tuple<int, char> mytuple(10, 'x');    //计算 mytuple 存储元素的个数    size = std::tuple_size<decltype(mytuple)>::value;    //输出 mytuple 中存储的元素    std::cout << std::get<0>(mytuple) << " " << std::get<1>(mytuple) << std::endl;    //修改指定的元素    std::get<0>(mytuple) = 100;    std::cout << std::get<0>(mytuple) << std::endl;    //使用 makde_tuple() 创建一个 tuple 对象    auto bar = std::make_tuple("test", 3.1, 14);    //拆解 bar 对象，分别赋值给 mystr、mydou、myint    const char* mystr = nullptr;    double mydou;    int myint;    //使用 tie() 时，如果不想接受某个元素的值，实参可以用 std::ignore 代替    std::tie(mystr, mydou, myint) = bar;    //std::tie(std::ignore, std::ignore, myint) = bar;  //只接收第 3 个整形值    //将 mytuple 和 bar 中的元素整合到 1 个 tuple 对象中    auto mycat = std::tuple_cat(mytuple, bar);    size = std::tuple_size<decltype(mycat)>::value;    std::cout << size << std::endl;    return 0;}
```

程序执行结果为：

```
10 x1005
```





# 10. C++11列表初始化（统一了初始化方式）

在 [C++](http://c.biancheng.net/cplus/)98/03 中的对象初始化方法有很多种，初始化列表、拷贝初始化、直接初始化等，但这些种类繁多的初始化方法，没有一种可以通用所有情况。为了统一初始化方式，并且让初始化行为具有确定的效果，C++11提出了列表初始化（List-initialization）的概念

```c++
class Foo{public:    Foo(int) {}private:    Foo(const Foo &);};int main(void){    Foo a1(123);	//构造函数    Foo a2 = 123;  //error: 'Foo::Foo(const Foo &)' is private    Foo a3 = { 123 };	//列表初始化    Foo a4 { 123 };		//列表初始化    int a5 = { 3 };	//列表初始化    int a6 { 3 };	//列表初始化    return 0;}
```

在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。

a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。

这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。

a4 和 a6 的写法，是 C++98/03 所不具备的。**在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化，即在初始化时，`{}`前面的等于号是否书写对初始化行为没有影响。**

另外，new 操作符等可以用圆括号进行初始化的地方，也可以使用初始化列表：

```c++
int* a = new int { 123 };double b = double { 12.12 };int* arr = new int[3] { 1, 2, 3 };
```

列表初始化还可以直接使用在函数的返回值上

```c++
struct Foo
{
    Foo(int, double) {}
};
Foo func(void)
{
    return { 123, 321.0 };	//这里的 return 语句就如同返回了一个 Foo(123, 321.0)
}
```





# 11.  C++11 lambda匿名函数

就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式

## lambda函数的定义

```c++
[外部变量访问方式说明符] (参数) mutable noexcept/throw() -> 返回值类型
{
  函数体;
};
```

其中各部分的含义分别为：

1）[外部变量方位方式说明符]
[ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。**在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”**。

> 所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。

2） (参数)
和普通函数的定义一样，lambda 匿名函数也可以**接收外部传递的多个参数**。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；

3） mutable
此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。**默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字**。

注意，对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；

4）noexcept/throw()
可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而**标注 noexcept 关键字，则表示函数体内不会抛出任何异常**；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。

值得一提的是，如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败（本节后续会给出实例）。

5） -> 返回值类型
指明 lambda 匿名函数的**返回值类型**。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略`-> 返回值类型`。

6）函数体
和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，**还可以使用指定的外部变量以及全局范围内的所有全局变量**。

需要注意的是，**外部变量会受到以值传递还是以引用传递方式引入的影响**，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值。

> 其中，外部变量方位方式说明符是定义 lambda 表达式时必须写的，而其他参数在不同的情况下可以省略。

比如，如下就定义了一个最简单的 lambda 匿名函数：

```c++
[]{}	//一个没有任何功能的lambda函数
```

## lambda匿名函数中的[外部变量]

对于 lambda 匿名函数的使用，令多数初学者感到困惑的就是 [外部变量] 的使用。其实很简单，无非表 1 所示的这几种编写格式。

| 外部变量格式      | 功能                                                         |
| ----------------- | ------------------------------------------------------------ |
| []                | 空方括号表示当前 lambda 匿名函数中不导入任何外部变量。       |
| [=]               | 只有一个 = 等号，表示以值传递的方式导入所有外部变量；        |
| [&]               | 只有一个 & 符号，表示以引用传递的方式导入所有外部变量；      |
| [val1,val2,...]   | 表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序； |
| [&val1,&val2,...] | 表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序； |
| [val,&val2,...]   | 以上 2 种方式还可以混合使用，变量之间没有前后次序。          |
| [=,&val1,...]     | 表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。 |
| [this]            | 表示以值传递的方式导入当前的 this 指针。                     |

>  注意，单个外部变量不允许以相同的传递方式导入多次。例如 [=，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。

【例 1】lambda 匿名函数的定义和使用。

```c++
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
    int num[4] = {4, 2, 3, 1};
    //对 a 数组中的元素进行排序
    sort(num, num+4, [=](int x, int y) -> bool{ return x < y; } );
    for(int n : num){
        cout << n << " ";
    }
    return 0;
}
```

程序执行结果为：

```
1 2 3 4
```

程序第 9 行通过调用 sort() 函数实现了对 num 数组中元素的升序排序，其中就用到了 lambda 匿名函数。

虽然 lambda 匿名函数没有函数名称，但我们仍可以为其手动设置一个名称，比如：

```c++
#include <iostream>
using namespace std;
int main()
{
    //display 即为 lambda 匿名函数的函数名
    auto display = [](int a,int b) -> void{cout << a << " " << b;};
    //调用 lambda 函数
    display(10,20);
    return 0;
}
```

程序执行结果为：

```
10 20
```





# 12.C++11非受限联合体

在 C/C++中，联合体（Union）是一种构造数据类型。在**一个联合体内，我们可以定义多个不同类型的成员，这些成员将会共享同一块内存空间**。老版本的 C++ 为了和C语言保持兼容，对联合体的数据成员的类型进行了很大程度的限制，这些限制在今天看来并没有必要，因此 C++11 取消了这些限制。

C++11 标准规定，任何非引用类型都可以成为联合体的数据成员，这种联合体也被称为非受限联合体。例如：

```c++
class Student{
public:
    Student(bool g, int a): gender(g), age(a) {}
private:
    bool gender;
    int age;
};
union T{
    Student s;  // 含有非POD类型的成员，gcc-5.1.0  版本报错
    char name[10];
};
int main(){
    return 0;
}
```

**1. C++11允许非POD类型**

C++98 不允许联合体的成员是非 POD 类型，但是 C++1 1 取消了这种限制。

POD 是 C++ 中一个比较重要的概念，在这里我们做一个简单介绍。POD 是英文 Plain Old Data 的缩写，用来描述一个类型的属性。

POD 类型一般具有以下几种特征（包括 class、union 和 struct等）：

1）没有用户自定义的构造函数、析构函数、拷贝构造函数和移动构造函数。

2） 不能包含虚函数和虚基类。

3） 非静态成员必须声明为 public。

4）类中的第一个非静态成员的类型与其基类不同，例如：

```c++
class B1{};
class B2 : B1 { B1 b; };
```

class B2 的第一个非静态成员 b 是基类类型，所以它不是 POD 类型。

5）在类或者结构体继承时，满足以下两种情况之一：

- 派生类中有非静态成员，且只有一个仅包含静态成员的基类；
- 基类有非静态成员，而派生类没有非静态成员。

我们来看具体的例子：

class B1 { static int n; };
class B2 : B1 { int n1; };
class B3 : B2 { static int n2; };

对于 B2，派生类 B2 中有非静态成员，且只有一个仅包含静态成员的基类 B1，所以它是 POD 类型。对于 B3，基类 B2 有非静态成员，而派生类 B3 没有非静态成员，所以它也是 POD 类型。

6）所有非静态数据成员均和其基类也符合上述规则（递归定义），也就是说 POD 类型不能包含非 POD 类型的数据。

7）此外，所有兼容C语言的数据类型都是 POD 类型（struct、union 等不能违背上述规则）。

**2.C++11允许联合体有静态成员**

如：

```c++
union U {    static int func() {        int n = 3;        return n;    }};
```

需要注意的是，静态成员变量只能在联合体内定义，却不能在联合体外使用，这使得该规则很没用。

**非受限联合体赋值注意事项**

C++11 规定，如果非受限联合体内有一个非 POD 的成员，而该成员拥有自定义的构造函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将被删除。

这条规则可能导致对象构造失败，请看下面的例子

```c++
#include <string>
using namespace std;
union U {
    string s;
    int n;
};
int main() {
    U u;   // 构造失败，因为 U 的构造函数被删除
    return 0;
}
```

在上面的例子中，因为 string 类拥有自定义的构造函数，所以 U 的构造函数被删除；定义 U 的类型变量 u 需要调用默认构造函数，所以 u 也就无法定义成功。

解决方法：placement new

placement new 是 new 关键字的一种进阶用法，既可以在栈（stack）上生成对象，也可以在堆（heap）上生成对象。相对应地，我们把常见的 new 的用法称为 operator new，它只能在 heap 上生成对象。

placement new 的语法格式如下：

```c++
new(address) ClassConstruct(...)	//address 表示已有内存的地址，该内存可以在栈上，也可以在堆上；ClassConstruct(...) 表示调用类的构造函数，如果构造函数没有参数，也可以省略括号。
```

**非受限联合体的匿名声明和“枚举式类”**

```c++
union U{	union{int x;}	//此联合体为匿名联合体（没有名字的联合体）}
```

同样的，非受限联合体也可以匿名，而当非受限的匿名联合体运用于类的声明时，这样的类被称为“枚举式类”。



# 13.C++11 for循环（基于范围的循环）

C++ 11标准之前（C++ 98/03 标准），如果要用 for 循环语句遍历一个数组或者容器，只能套用如下结构：

```c++
for(表达式 1; 表达式 2; 表达式 3){  //循环体}
```

而 C++ 11 标准中，除了可以沿用前面介绍的用法外，还为 for 循环添加了一种全新的语法格式，如下所示：

```c++
for (declaration : expression){  //循环体}
```

其中，两个参数各自的含义如下：

- declaration：**表示此处要定义一个变量，该变量的类型为要遍历序列中存储元素的类型**。需要注意的是，C++ 11 标准中，declaration参数处定义的变量类型**可以用 auto 关键字**表示，该关键字可以使编译器自行推导该变量的数据类型。
- expression：表示要遍历的序列，常见的**可以为事先定义好的普通数组或者容器**，还**可以是用 {} 大括号初始化的序列**。

旧格式的 for 循环可以指定循环的范围，而C++11 标准增加的 for 循环，只会逐个遍历 expression 参数处指定序列中的每个元素

新格式的 for 循环在遍历**字符串序列**时，不只是遍历到最后一个字符，还会遍历位于该字符串末尾的 '\0'（字符串的结束标志）

示例

```c++
vector<char>myvector(arc, arc + 23);//for循环遍历 vector 容器for (auto ch : myvector) {cout << ch;}//遍历初始化列表for (int num : {1, 2, 3, 4, 5}) {cout << num << " ";}
```

在使用新语法格式的 for 循环遍历某个序列时，如果需要遍历的同时修改序列中元素的值，**实现方案是在 declaration 参数处定义引用形式的变量**。

```c++
for (auto &ch : myvector) {ch++;		//将myvector中每个元素加1}
```

# 14.C++11 for循环使用注意事项

1）首先需要明确的一点是，当使用 for 循环遍历某个序列时，**无论该序列是普通数组、容器还是用`{ }`大括号包裹的初始化列表，遍历序列的变量都表示的是当前序列中的各个元素**。

2）基于范围的 for 循环可以直接遍历初始化列表，也可以直接遍历字符串，也可以遍历 string 类型的字符串，这种情况下冒号前定义 char 类型的变量即可

3）for 循环冒号后还可以放置返回 string 字符串以及容器对象的函数，且整个遍历过程中，函数只会执行一次。

如：

```c++
#include <iostream>#include <vector>#include <string>using namespace std;string str = "xiaodexin";vector<int> myvector = { 1,2,3,4,5 };string retStr() {    cout<<"name:"<<endl;    return str;}vector<int> retVector() {    return myvector;}int main() {    //遍历函数返回的 string 字符串    for (char ch : retStr()) {        cout << ch;    }    cout << endl;    //遍历函数返回的 vector 容器    for (int num : retVector()) {        cout << num << " ";    }    return 0;}
```

执行结果：

```
name:xiaodexin1 2 3 4 5
```

4）基于范围的 for 循环不支持遍历函数返回的以指针形式表示的数组

```c++
char str[] = "xiaodexin";char* retStr() {    return str;}int main() {    for (char ch : retStr()) //直接报错    {        cout << ch;    }    return 0;}
```

5）基于关联式容器（包括哈希容器）底层存储机制的限制：

不允许修改 map、unordered_map、multimap 以及 unordered_multimap 容器存储的键的值；

不允许修改 set、unordered_set、multiset 以及 unordered_multiset 容器中存储的元素的值。

**因此，当使用基于范围的 for 循环遍历此类型容器时，切勿修改容器中不允许被修改的数据部分，否则会导致程序的执行出现各种 Bug。**

6）基于范围的 for 循环完成对容器的遍历，其底层也是借助容器的迭代器实现的，由于当对容器进行扩增等操作时其迭代器可能发生改变，因此，在使用基于范围的 for 循环遍历容器时，应避免在循环体中修改容器存储元素的个数。

# 15.C++11 constexpr：验证是否为常量表达式

常量表达式：由多个（≥1）常量组成的表达式（表达式中的成员都是常量，不可修改）。

常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。

**constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。**C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。

## constexpr修饰普通变量

定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。

使用 constexpr 修改普通变量时，变量必须经过初始化且初始值必须是一个常量表达式

```c++
#include <iostream>
using namespace std;
int main()
{
    constexpr int num = 1 + 2 + 3;
    int url[num] = {1,2,3,4,5,6};
    couts<< url[1] << endl;
    return 0;
}
```

程序执行结果为：

```
2
```

> 如果将 constexpr 删除，此时编译器会提示“url[num] 定义中 num 不可用作常量”。

将此示例程序中的 constexpr 用 const 关键字替换也可以正常执行，这是因为 num 的定义同时满足“num 是 const 常量且使用常量表达式为其初始化“这 2 个条件，由此编译器会认定 num 是一个常量表达式。

**注意：**当常量表达式中包含浮点数时，考虑到程序编译和运行所在的系统环境可能不同，常量表达式在编译阶段和运行阶段计算出的结果精度很可能会受到影响，因此 C++11 标准规定，浮点常量表达式在编译阶段计算的精度要至少等于（或者高于）运行阶段计算出的精度。

## constexpr修饰函数

constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。一个函数要想成为常量表达式函数，必须满足如下 4 个条件。

1）整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。

例如

```c++
constexpr int display(int x) {    int ret = 1 + 2 + x;    return ret;}
```

无法通过编译，因为该函数的返回值用 constexpr 修饰，但函数内部包含多条语句。

如下是正确的定义 display() 常量表达式函数的写法：

```c++
constexpr int display(int x) {        //可以添加 using 执行、typedef 语句以及 static_assert 断言        return 1 + 2 + x;}
```

可以看到，display() 函数的返回值是用 constexpr 修饰的 int 类型值，且该函数的函数体中只包含一个 return 语句。

2）该函数必须有返回值，即函数的返回值类型不能是 void

3）函数在使用之前，必须有对应的定义语句。我们知道，函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在使用前，必须要有该函数的定义。

4）return 返回的表达式必须是常量表达式

## constexpr修饰类的构造函数

对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。

如以下是无法通过编译的，编译器会抛出“constexpr不能修饰自定义类型”的异常：

```c++
#include <iostream>using namespace std;//自定义类型的定义constexpr struct myType {    const char* name;    int age;    //其它结构体成员};int main(){    constexpr struct myType mt { "zhangsan", 10 };    cout << mt.name << " " << mt.age << endl;    return 0;}
```

当我们**想自定义一个可产生常量的类型时，正确的做法是在该类型的内部添加一个常量构造函数**。例如，修改上面的错误示例如下：

```c++
#include <iostream>using namespace std;//自定义类型的定义struct myType {    constexpr myType(char *name,int age):name(name),age(age){};    const char* name;    int age;    //其它结构体成员};int main(){    constexpr struct myType mt { "zhangsan", 10 };    cout << mt.name << " " << mt.age << endl;    return 0;}
```

**注意，constexpr 修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。**onstexpr 可用于修饰函数，而类中的成员方法完全可以看做是“位于类这个命名空间中的函数”，所以 constexpr 也可以修饰类中的成员函数，只不过此函数必须满足前面提到的 4 个条件。

## constexpr修饰模板函数

C++11 语法中，constexpr 可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。

针对这种情况下，C++11 标准规定，如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。

举例：

```c++
#include <iostream>
using namespace std;
//自定义类型的定义
struct myType {
    const char* name;
    int age;
    //其它结构体成员
};
//模板函数
template<typename T>
constexpr T dispaly(T t){
    return t;
}
int main()
{
    struct myType stu{"zhangsan",10};
    //普通函数
    struct myType ret = dispaly(stu);
    cout << ret.name << " " << ret.age << endl;
    //常量表达式函数
    constexpr int ret1 = dispaly(10);
    cout << ret1 << endl;
    return 0;
}
```

程序执行结果为：

```
zhangsan 10
10
```

可以看到，示例程序中定义了一个模板函数 display()，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：

- 第 20 行代码处，当模板函数中以自定义结构体 myType 类型进行实例化时，由于该结构体中没有定义常量表达式构造函数，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的；
- 第 23 行代码处，模板函数的类型 T 为 int 类型，实例化后的函数符合常量表达式函数的要求，所以该函数的返回值就是一个常量表达式。

# 16.constexpr和const的区别

原C++98中const有可能表达两种语义：只读变量及常量

```c++
const int a;// a 是一个只读的变量，其本质仍为变量const int b = 5;// b 是一个只读的变量，还是一个值为 5 的常量
```

**C++11规定凡是表达“只读”语义的场景都使用 const，表达“常量”语义的场景都使用 constexpr**

所以在上述中dis2()应该使用constexptr关键字

```c++
constexpr int b = 5;
```

大部分情况下const与constexpr可以混用，但是在一些情况下不可以，例如

```c++
#include <iostream>#include <array>using namespace std;constexpr int sqr1(int arg){    return arg*arg;}const int sqr2(int arg){    return arg*arg;}int main(){    array<int,sqr1(10)> mylist1;//可以，因为sqr1是constexpr函数    array<int,sqr2(10)> mylist1;//不可以，因为sqr2不是constexpr函数，即sqr2的返回值是一个const变量，无法用于初始化 array 容器（只有常量才能初始化 array 容器）       return 0;}
```





# 17.C++11 long long超长整形

C++11标准中所有的整形数据类型

| 整数类型                        | 等价类型                                 | C++11标准规定占用最少位数 |
| :------------------------------ | ---------------------------------------- | ------------------------- |
| short                           | short int（有符号短整型）                | 至少 16 位（2 个字节）    |
| signed short                    |                                          |                           |
| signed short int                |                                          |                           |
| unsigned short                  | unsigned short int（无符号短整型）       |                           |
| unsigned short int              |                                          |                           |
| int                             | int（有符号整形）                        | 至少 16 位（2 个字节）    |
| signed                          |                                          |                           |
| signed int                      |                                          |                           |
| unsigned                        | unsigned int（无符号整形）               |                           |
| unsigned int                    |                                          |                           |
| long                            | long int（有符号长整形）                 | 至少 32 位（4 个字节）    |
| long int                        |                                          |                           |
| signed long                     |                                          |                           |
| signed long int                 |                                          |                           |
| unsigned long                   | unsigned long int（无符号长整形）        |                           |
| unsigned long int               |                                          |                           |
| long long（C++11）              | long long int（有符号超长整形）          | 至少 64 位（8 个字节）    |
| long long int（C++11）          |                                          |                           |
| signed long long（C++11）       |                                          |                           |
| signed long long int（C++11）   |                                          |                           |
| unsigned long long（C++11）     | unsigned long long int（无符号超长整型） |                           |
| unsigned long long int（C++11） |                                          |                           |

注：C++11 标准中只限定了每种类型最少占用多少存储空间，不同的平台可以占用不同的存储空间。

如同 long 类型整数需明确标注 "L" 或者 "l" 后缀一样，要使用 long long 类型的整数，也必须标注对应的后缀：

- 对于有符号 long long 整形，后缀用 "LL" 或者 "ll" 标识。例如，"10LL" 就表示有符号超长整数 10；
- 对于无符号 long long 整形，后缀用 "ULL"、"ull"、"Ull" 或者 "uLL" 标识。例如，"10ULL" 就表示无符号超长整数 10；



# 18.C++11右值引用

C++11最重要的特性之一

右值引用只不过是一种新的 C++ 语法，真正理解起来有难度的是基于右值引用引申出的 2 种 C++ 编程技巧，分别为**移动语义和完美转发**。

## C++左值右值两种判断方法：

1）可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。举个例子：

```c++
int a = 5;5 = a; //错误，5 不能为左值
```

其中，变量 a 就是一个左值，而字面量 5 就是一个右值。值得一提的是，C++ 中的左值也可以当做右值使用，例如：

```c++
int b = 10; // b 是一个左值
a = b; // a、b 都是左值，只不过将 b 可以当做右值使用
```

2）有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。

以上面定义的变量 a、b 为例，a 和 b 是变量名，且**通过 &a 和 &b 可以获得他们的存储地址**，因此 a 和 b 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。 

## C++右值引用

前面提到，其实 C++98/03 标准中就有引用，使用 "&" 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：

```c++
int num = 10;
int &b = num; //正确
int &c = 10; //错误
```

如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用。

注意，虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，**常量左值引用既可以操作左值，也可以操作右值**，例如：

```c++
int num = 10;const int &b = num;const int &c = 10;
```

我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。

为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 "&&" 表示。

需要注意的，和声明左值引用一样，**右值引用也必须立即进行初始化操作，且只能使用右值进行初始化**，比如：

```c++
int num = 10;//int && a = num;  //右值引用不能初始化为左值int && a = 10;
```

和常量左值引用不同的是，**右值引用还可以对右值进行修改（左值引用不可以）**。例如：

```c++
int && a = 10;a = 100;	//右值引用可以对右值进行修改cout << a << endl;int b = 10;int d = 2;int &c = b;		//左值引用只能引用bc = d;	//这句语句只是将b中的值改为了d中的值，并没有修改引用（还是引用的b）
```

C++ 语法上是支持定义常量右值引用的，但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。

```c++
const int&& a = 10;//编译器不会报错
```

总结：C++左值引用和右值引用

| 引用类型       | 可以引用的值类型 |          |            |          | 使用场景                   |
| -------------- | ---------------- | -------- | ---------- | -------- | -------------------------- |
|                | 非常量左值       | 常量左值 | 非常量右值 | 常量右值 |                            |
| 非常量左值引用 | Y                | N        | N          | N        | 无                         |
| 常量左值引用   | Y                | Y        | Y          | Y        | 常用于类中构建拷贝构造函数 |
| 非常量右值引用 | N                | N        | Y          | N        | 移动语义、完美转发         |
| 常量右值引用   | N                | N        | Y          | Y        | 无实际用途                 |



# 19.C++11移动构造函数的功能和用法（移动语义）

## C++11移动语义是什么

在 C++ 11 标准之前（C++ 98/03 标准中），如果想用其它对象初始化一个同类的新对象，只能借助类中的复制（拷贝）构造函数。拷贝构造函数的实现原理很简单，就是为新对象复制一份和其它对象一模一样的数据。

> 需要注意的是，当类中拥有指针类型的成员变量时，拷贝构造函数中需要以深拷贝（而非浅拷贝）的方式复制该指针成员。

举个例子：

```c++
#include <iostream>using namespace std;class demo{public:   demo():num(new int(0)){      cout<<"construct!"<<endl;   }   //拷贝构造函数   demo(const demo &d):num(new int(*d.num)){      cout<<"copy construct!"<<endl;   }   ~demo(){      cout<<"class destruct!"<<endl;   }private:   int *num;};demo get_demo(){    return demo();}int main(){    demo a = get_demo();    return 0;}
```

> 如上所示，我们为 demo 类自定义了一个拷贝构造函数。该函数在拷贝 d.num 指针成员时，必须采用深拷贝的方式，即拷贝该指针成员本身的同时，还要拷贝指针指向的内存资源。否则一旦多个对象中的指针成员指向同一块堆空间，这些对象析构时就会对该空间释放多次，这是不允许的。

可以看到，程序中定义了一个可返回 demo 对象的 get_demo() 函数，用于在 main() 主函数中初始化 a 对象，其整个初始化的流程包含以下几个阶段：

1. 执行 get_demo() 函数内部的 demo() 语句，即调用 demo 类的默认构造函数生成一个匿名对象；
2. 执行 return demo() 语句，会调用拷贝构造函数复制一份之前生成的匿名对象，并将其作为 get_demo() 函数的返回值（函数体执行完毕之前，匿名对象会被析构销毁）；
3. 执行 a = get_demo() 语句，再调用一次拷贝构造函数，将之前拷贝得到的临时对象复制给 a（此行代码执行完毕，get_demo() 函数返回的对象会被析构）；
4. 程序执行结束前，会自行调用 demo 类的析构函数销毁 a。

注意，目前多数编译器都会对程序中发生的拷贝操作进行优化，因此如果我们使用 VS 2017、codeblocks 等这些编译器运行此程序时，看到的往往是优化后的输出结果：

```
construct!class destruct!
```

而同样的程序，如果在 Linux 上使用`g++ demo.cpp -fno-elide-constructors`命令运行（其中 demo.cpp 是程序文件的名称），就可以看到完整的输出结果：

```
construct!        <-- 执行 demo()copy construct!    <-- 执行 return demo()class destruct!     <-- 销毁 demo() 产生的匿名对象copy construct!    <-- 执行 a = get_demo()class destruct!     <-- 销毁 get_demo() 返回的临时对象class destruct!     <-- 销毁 a
```

如上所示，利用拷贝构造函数实现对 a 对象的初始化，底层实际上进行了 2 次拷贝（而且是深拷贝）操作。当然，对于仅申请少量堆空间的临时对象来说，深拷贝的执行效率依旧可以接受，但如果临时对象中的指针成员申请了大量的堆空间，那么 2 次深拷贝操作势必会影响 a 对象初始化的执行效率。

> 事实上，此问题一直存留在以 C++ 98/03 标准编写的 C++ 程序中。由于临时变量的产生、销毁以及发生的拷贝操作本身就是很隐晦的（编译器对这些过程做了专门的优化），且并不会影响程序的正确性，因此很少进入程序员的视野。

那么当类中包含指针类型的成员变量，使用其它对象来初始化同类对象时，怎样才能避免深拷贝导致的效率问题呢？C++11 标准引入了解决方案，该标准中引入了右值引用的语法，借助它可以实现移动语义。

## C++移动构造函数（移动语义的具体实现）

移动语义，指的就是**以移动而非深拷贝的方式初始化含有指针成员的类对象**。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。

以前面程序中的 demo 类为例，该类的成员都包含一个整形的指针成员，其默认指向的是容纳一个整形变量的堆空间。当使用 get_demo() 函数返回的临时对象初始化 a 时，我们只需要将临时对象的 num 指针直接浅拷贝给 a.num，然后修改该临时对象中 num 指针的指向（通常另其指向 NULL），这样就完成了 a.num 的初始化。

> 事实上，对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。

下面程序对 demo 类进行了修改：

```c++
#include <iostream>
using namespace std;
class demo{
public:
    demo():num(new int(0)){
        cout<<"construct!"<<endl;
    }
    demo(const demo &d):num(new int(*d.num)){
        cout<<"copy construct!"<<endl;
    }
    //添加移动构造函数
    demo(demo &&d):num(d.num){
        d.num = NULL;
        cout<<"move construct!"<<endl;
    }
    ~demo(){
        cout<<"class destruct!"<<endl;
    }
private:
    int *num;
};
demo get_demo(){
    return demo();
}
int main(){
    demo a = get_demo();
    return 0;
}
```

可以看到，在之前 demo 类的基础上，我们又手动为其添加了一个构造函数。和其它构造函数不同，此构造函数使用右值引用形式的参数，又称为移动构造函数。并且在此构造函数中，num 指针变量采用的是浅拷贝的复制方式，同时在函数内部重置了 d.num，有效避免了“同一块对空间被释放多次”情况的发生。

在 Linux 系统中使用`g++ demo.cpp -o demo.exe -std=c++0x -fno-elide-constructors`命令执行此程序，输出结果为：

```
construct!	move construct!		class destruct!move construct!class destruct!class destruct!
```

上述代码整个初始化的流程包含以下几个阶段：

1. 执行 get_demo() 函数内部的 demo() 语句，即调用 demo 类的默认构造函数生成一个匿名对象；
2. 执行 return demo() 语句，会调用移动拷贝构造函数复制一份之前生成的匿名对象，并将其作为 get_demo() 函数的返回值（函数体执行完毕之前，匿名对象会被析构销毁）；
3. 执行 a = get_demo() 语句，再调用一次移动拷贝构造函数，将之前拷贝得到的临时对象复制给 a（此行代码执行完毕，get_demo() 函数返回的对象会被析构）；
4. 程序执行结束前，会自行调用 demo 类的析构函数销毁 a。

我们知道，非 const 右值引用只能操作右值，**程序执行结果中产生的临时对象（例如函数返回值、lambda 表达式等）既无名称也无法获取其存储地址，所以属于右值**。**当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。**

> 在实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。

读者可能会问，如果使用左值初始化同类对象，但也想调用移动构造函数完成，有没有办法可以实现呢？

默认情况下，左值初始化同类对象只能通过拷贝构造函数完成，如果想调用移动构造函数，则必须使用右值进行初始化。**C++11 标准中为了满足用户使用左值初始化同类对象时也通过移动构造函数完成的需求，新引入了 std::move() 函数**，它可以将左值强制转换成对应的右值，由此便可以使用移动构造函数。



# 20. C++11 move()函数：将左值强制转换为右值

我们知道，C++11 标准中借助右值引用可以为指定类添加移动构造函数，这样当使用该类的右值对象（可以理解为临时对象）初始化同类对象时，编译器会优先选择移动构造函数。

注意，移动构造函数的调用时机是：**用同类的右值对象初始化新对象。**那么，用当前类的左值对象（有名称，能获取其存储地址的实例对象）初始化同类对象时，是否就无法调用移动构造函数了呢？当然不是，C++11 标准中已经给出了解决方案，即调用 move() 函数。

move 本意为 "移动"，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。

> 基于 move() 函数特殊的功能，其常用于实现移动语义。

move() 函数的用法也很简单，其语法格式如下：

```c++
move(arg)	//arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。
```

```c++
#include <iostream>
using namespace std;

class movedemo{
public:
    movedemo():num(new int(0)){
        cout<<"construct!"<<endl;
    }
    //拷贝构造函数
    movedemo(const movedemo &d):num(new int(*d.num)){
        cout<<"copy construct!"<<endl;
    }
    //移动构造函数
    movedemo(movedemo &&d):num(d.num){
        d.num = NULL;
        cout<<"move construct!"<<endl;
    }
public:     //这里应该是 private，使用 public 是为了更方便说明问题
    int *num;
};

int main(){
    movedemo demo;
    cout << "demo2:\n";
    movedemo demo2 = demo;
    //cout << *demo2.num << endl;   //可以执行
    cout << "demo3:\n";
    movedemo demo3 = std::move(demo);
    //此时 demo.num = NULL，因此下面代码会报运行时错误
    //cout << *demo.num << endl;
    return 0;
}
```

程序执行结果为：

```
construct!
demo2:
copy construct!
demo3:
move construct!
```

通过观察程序的输出结果，以及对比 demo2 和 demo3 初始化操作不难得知，demo 对象作为左值，直接用于初始化 demo2 对象，其底层调用的是拷贝构造函数；而通过调用 move() 函数可以得到 demo 对象的右值形式，用其初始化 demo3 对象，编译器会优先调用移动构造函数。

> 注意，调用拷贝构造函数，并不影响 demo 对象，但如果调用移动构造函数，由于函数内部会重置 demo.num 指针的指向为 NULL，所以程序中第 30 行代码会导致程序运行时发生错误。



例：灵活使用move()函数

```c++
#include <iostream>
using namespace std;
class first {
public:
    first() :num(new int(0)) {
        cout << "construct!" << endl;
    }
    //移动构造函数
    first(first &&d) :num(d.num) {
        d.num = NULL;
        cout << "first move construct!" << endl;
    }
public:    //这里应该是 private，使用 public 是为了更方便说明问题
    int *num;
};
class second {
public:
    second() :fir() {}
    //用 first 类的移动构造函数初始化 fir
    second(second && sec) :fir(move(sec.fir)) {
        cout << "second move construct" << endl;
    }
public:    //这里也应该是 private，使用 public 是为了更方便说明问题
    first fir;
};
int main() {
    second oth;
    second oth2 = move(oth);
    //cout << *oth.fir.num << endl;   //程序报运行时错误
    return 0;
}
```

程序执行结果为：

```
construct!first move construct!second move construct
```

程序中分别构建了 first 和 second 这 2 个类，其中 second 类中包含一个 first 类对象。如果读者仔细观察不难发现，程序中使用了 2 此 move() 函数：

- 程序第 31 行：由于 oth 为左值，如果想调用移动构造函数为 oth2 初始化，需先利用 move() 函数生成一个 oth 的右值版本；
- 程序第 22 行：oth 对象内部还包含一个 first 类对象，对于 oth.fir 来说，其也是一个左值，所以在初始化 oth.fir 时，还需要再调用一次 move() 函数。





# 21. C++11引用限定符的用法

左值和右值的区分也同样适用于类对象，本节中将左值的类对象称为左值对象，将右值的类对象称为右值对象。

默认情况下，对于类中用 public 修饰的成员函数，既可以被左值对象调用，也可以被右值对象调用。

某些场景中，我们可能需要限制调用成员函数的对象的类型（左值还是右值），为此 C++11 新添加了引用限定符。所谓引用限定符，就是在成员函数的后面添加 "&" 或者 "&&"，从而限制调用者的类型（左值还是右值）。

```C++
#include <iostream>using namespace std;class demo {public:    demo(int num):num(num){}    int get_num()&{        return this->num;    }private:    int num;};int main() {    demo a(10);    cout << a.get_num() << endl;          // 正确    //cout << move(a).get_num() << endl;  // 错误    return 0;}
```

在 get_num() 成员函数的后面添加了 "&"，它可以限定调用该函数的对象必须是左值对象。因此第 16 行代码中，move(a) 生成的右值对象是不允许调用 get_num() 函数的。



```C++
#include <iostream>using namespace std;class demo {public:    demo(int num):num(num){}    int get_num()&&{        return this->num;    }private:    int num;};int main() {    demo a(10);    //cout << a.get_num() << endl;      // 错误    cout << move(a).get_num() << endl;  // 正确    return 0;}
```

和先前程序不同的是，get_num() 函数后根有 "&&" 限定符，它可以限定调用该函数的对象必须是一个右值对象。

> 注意，引用限定符不适用于静态成员函数和友元函数。
>
> 

## const和引用限定符

我们知道，const 也可以用于修饰类的成员函数，我们习惯称为常成员函数，例如：

```C++
class demo{public:    int get_num() const;}
```

这里的 get_num() 就是一个常成员函数。

const 和引用限定符修饰类的成员函数时，都位于函数的末尾。C++11 标准规定，当引用限定符和 const 修饰同一个类的成员函数时，const 必须位于引用限定符前面。

需要注意的一点是，**当 const && 修饰类的成员函数时，调用它的对象只能是右值对象；当 const & 修饰类的成员函数时，调用它的对象既可以是左值对象，也可以是右值对象。**无论是 const && 还是 const & 限定的成员函数，内部都不允许对当前对象做修改操作。





# 22. C++11完美转发及其实现

C++11 标准为 C++ 引入右值引用语法的同时，还解决了一个 C++ 98/03 标准长期存在的短板，即使用简单的方式即可在函数模板中实现参数的完美转发。

完美转发，指的是**函数模板可以将自己的参数“完美”地转发给内部调用的其它函数。所谓完美，即不仅能准确地转发参数的值，还能保证被转发参数的左、右值属性不变。**

举个例子：

```c++
template<typename T>
void function(T t) {
    otherdef(t);
}
```

如上所示，function() 函数模板中调用了 otherdef() 函数。在此基础上，**完美转发指的是：如果 function() 函数接收到的参数 t 为左值，那么该函数传递给 otherdef() 的参数 t 也是左值；反之如果 function() 函数接收到的参数 t 为右值，那么传递给 otherdef() 函数的参数 t 也必须为右值。**

显然，function() 函数模板并没有实现完美转发。一方面，参数 t 为非引用类型，这意味着在调用 function() 函数时，实参将值传递给形参的过程就需要额外进行一次拷贝操作；另一方面，无论调用 function() 函数模板时传递给参数 t 的是左值还是右值，对于函数内部的参数 t 来说，它有自己的名称，也可以获取它的存储地址，因此它永远都是左值，也就是说，传递给 otherdef() 函数的参数 t 永远都是左值。总之，无论从那个角度看，function() 函数的定义都不“完美”。

> 完美转发这样严苛的参数传递机制，很常用吗？实际上，C++98/03 标准中几乎不会用到，但 C++11 标准为 C++ 引入了右值引用和移动语义，因此很多场景中是否实现完美转发，直接决定了该参数的传递过程使用的是拷贝语义（调用拷贝构造函数）还是移动语义（调用移动构造函数）。


事实上，C++98/03 标准下的 C++ 也可以实现完美转发，只是实现方式比较笨拙。通过前面的学习我们知道，**C++ 98/03 标准中只有左值引用，并且可以细分为非 const 引用和 const 引用。其中，使用非 const 引用作为函数模板参数时，只能接收左值，无法接收右值；而 const 左值引用既可以接收左值，也可以接收右值，但考虑到其 const 属性，除非被调用函数的参数也是 const 属性，否则将无法直接传递**。

这也就意味着，单独使用任何一种引用形式，可以实现转发，但无法保证完美。因此如果使用 C++ 98/03 标准下的 C++ 语言，我们可以采用函数模板重载的方式实现完美转发，例如：

```c++
#include <iostream>
using namespace std;

//重载被调用函数，查看完美转发的效果
void otherdef(int & t) {
    cout << "lvalue\n";
}
void otherdef(const int & t) {
    cout << "rvalue\n";
}

//重载函数模板，分别接收左值和右值
//接收右值参数
template <typename T>
void function(const T& t) {
    otherdef(t);
}
//接收左值参数
template <typename T>
void function(T& t) {
    otherdef(t);
}

int main()
{
    function(5);//5 是右值
    int  x = 1;
    function(x);//x 是左值
    return 0;
}
```

程序执行结果为：

```
rvalue
lvalue
```

从输出结果中可以看到，对于右值 5 来说，它实际调用的参数类型为 const T& 的函数模板，由于 t 为 const 类型，所以 otherdef() 函数实际调用的也是参数用 const 修饰的函数，所以输出“rvalue”；对于左值 x 来说，2 个重载模板函数都适用，C++编译器会选择最适合的参数类型为 T& 的函数模板，进而 therdef() 函数实际调用的是参数类型为非 const 的函数，输出“lvalue”。

显然，使用重载的模板函数实现完美转发也是有弊端的，此实现方式仅适用于模板函数仅有少量参数的情况，否则就需要编写大量的重载函数模板，造成代码的冗余。为了方便用户更快速地实现完美转发，**C++ 11 标准中允许在函数模板中使用右值引用来实现完美转发**。



C++11 标准中规定，通常情况下右值引用形式的参数只能接收右值，不能接收左值。但**对于函数模板中使用右值引用语法定义的参数来说，它不再遵守这一规定，既可以接收右值，也可以接收左值**（此时的右值引用又被称为“万能引用”）。

仍以 function() 函数为例，**在 C++11 标准中实现完美转发，**只需要编写如下一个模板函数即可：

```c++
template <typename T>
void function(T&& t) {
    otherdef(t);
}
```

此模板函数的参数 t 既可以接收左值，也可以接收右值。但仅仅使用右值引用作为函数模板的参数是远远不够的，还有一个问题继续解决，即如果调用 function() 函数时为其传递一个左值引用或者右值引用的实参，如下所示：

```c++
int n = 10;
int & num = n;
function(num); // T 为 int&
int && num2 = 11;
function(num2); // T 为 int &&
```

其中，由 function(num) 实例化的函数底层就变成了 function(int & & t)，同样由 function(num2) 实例化的函数底层则变成了 function(int && && t)。要知道，C++98/03 标准是不支持这种用法的，而 C++ 11标准为了更好地实现完美转发，特意为其指定了新的类型匹配规则，又称为引用折叠规则（假设用 A 表示实际传递参数的类型）：

- 当实参为左值或者左值引用（A&）时，函数模板中 T&& 将转变为 A&（A& && = A&）；
- 当实参为右值或者右值引用（A&&）时，函数模板中 T&& 将转变为 A&&（A&& && = A&&）。

> 我们只需要知道，**在实现完美转发时，只要函数模板的参数类型为 T&&，则 C++ 可以自行准确地判定出实际传入的实参是左值还是右值。**

通过将函数模板的形参类型设置为 T&&，我们可以很好地解决接收左、右值的问题。但除此之外，还需要解决一个问题，即无论传入的形参是左值还是右值，**对于函数模板内部来说**，形参既有名称又能寻址，因此它都是左值。那么如何才能将函数模板接收到的形参连同其左、右值属性，一起传递给被调用的函数呢？

C++11 标准的开发者已经帮我们想好的解决方案，该新标准还引入了一个模板函数 forword<T>()，我们只需要调用该函数，就可以很方便地解决此问题。仍以 function 模板函数为例，如下演示了该函数模板的用法：

```c++
#include <iostream>
using namespace std;
//重载被调用函数，查看完美转发的效果
void otherdef(int & t) {
    cout << "lvalue\n";
}
void otherdef(const int & t) {
    cout << "rvalue\n";
}
//实现完美转发的函数模板
template <typename T>
void function(T&& t) {
    otherdef(forward<T>(t));
}
int main()
{
    function(5);
    int  x = 1;
    function(x);
    return 0;
}
```

程序执行结果为：

```
rvalue
lvalue
```

**第 12~16 行的 function() 模板函数才是实现完美转发的最终版本。**

总的来说，**在定义模板函数时，我们采用右值引用的语法格式定义参数类型，由此该函数既可以接收外界传入的左值，也可以接收右值；其次，还需要使用 C++11 标准库提供的 forword() 模板函数修饰被调用函数中需要维持左、右值属性的参数。由此即可轻松实现函数模板中参数的完美转发。** 





# 23. C++11 nullptr：初始化空指针

实际开发中，避免产生“野指针”最有效的方法，就是在定义指针的同时完成初始化操作，即便该指针的指向尚未明确，也要将其初始化为空指针。

> 所谓“野指针”，又称“悬挂指针”，指的是没有明确指向的指针。野指针往往指向的是那些不可用的内存区域，这就意味着像操作普通指针那样使用野指针（例如 &p），极可能导致程序发生异常。

C++98/03 标准中，将一个指针初始化为空指针的方式有 2 种：

```c++
int *p = 0;、
int *p = NULL; //推荐使用
```

可以看到，我们可以将指针明确指向 0（0x0000 0000）这个内存空间。一方面，明确指针的指向可以避免其成为野指针；另一方面，大多数操作系统都不允许用户对地址为 0 的内存空间执行写操作，若用户在程序中尝试修改其内容，则程序运行会直接报错。

相比第一种方式，我们更习惯将指针初始化为 NULL。值得一提的是，NULL 并不是 C++ 的关键字，它是 C++ 为我们事先定义好的一个宏，并且它的值往往就是字面量 0（#define NULL 0）。

C++ 中将 NULL 定义为字面常量 0，虽然能满足大部分场景的需要，但个别情况下，它会导致程序的运行和我们的预期不符。例如：

```c++
#include <iostream>
using namespace std;
void isnull(void *c){
    cout << "void*c" << endl;
}
void isnull(int n){
    cout << "int n" << endl;
}
int main() {
    isnull(0);
    isnull(NULL);
    return 0;
}
```

程序执行结果为：

```c++
int n
int n
```

对于 isnull(0) 来说，显然它真正调用的是参数为整形的 isnull() 函数；而对于 isnull(NULL)，我们期望它实际调用的是参数为 void*c 的 isnull() 函数，但观察程序的执行结果不难看出，并不符合我们的预期。

C++ 98/03 标准中，如果我们想令 isnull(NULL) 实际调用的是 isnull(void* c)，就需要对 NULL（或者 0）进行强制类型转换：

```c++
isnull( (void*)NULL );
isnull( (void*)0 );
```

如此，才会成功调用我们预期的函数。

由于 C++ 98 标准使用期间，NULL 已经得到了广泛的应用，出于兼容性的考虑，C++11 标准并没有对 NULL 的宏定义做任何修改。为了修正 C++ 存在的这一 BUG，C++ 标准委员会最终决定另其炉灶，在 C++11 标准中引入一个新关键字，即 nullptr。

**nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。**nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullptr 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。

值得一提的是，nullptr 可以被隐式转换成任意的指针类型。举个例子：

```c++
int * a1 = nullptr;
char * a2 = nullptr;
double * a3 = nullptr;
```

显然，不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int*、char* 以及 double* 指针类型。

另外，通过将指针初始化为 nullptr，可以很好地解决 NULL 遗留的问题。

> 总之在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮。





# 24. C++11 shared_ptr智能指针

## 智能指针

在实际的 C++ 开发中，我们经常会遇到诸如程序运行中突然崩溃、程序运行所用内存越来越多最终不得不重启等问题，这些问题往往都是内存资源管理不当造成的。比如：

- 有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；
- 有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；
- 没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。

针对以上这些情况，很多程序员认为 C++ 语言应该提供更友好的内存管理机制，这样就可以将精力集中于开发项目的各个功能上。

事实上，显示内存管理的替代方案很早就有了，早在 1959 年前后，就有人提出了“垃圾自动回收”机制。所谓垃圾，指的是那些不再使用或者没有任何指针指向的内存空间，而“回收”则指的是将这些“垃圾”收集起来以便再次利用。

如今，垃圾回收机制已经大行其道，得到了诸多编程语言的支持，例如 Java、Python、C#、PHP 等。而 C++ 虽然从来没有公开得支持过垃圾回收机制，但 C++98/03 标准中，支持使用 auto_ptr 智能指针来实现堆内存的自动回收；C++11 新标准在废弃 auto_ptr 的同时，**增添了 unique_ptr、shared_ptr 以及 weak_ptr 这 3 个智能指针来实现堆内存的自动回收**。

所谓智能指针，可以从字面上理解为“智能”的指针。具体来讲，智能指针和普通指针的用法是相似的，不同之处在于，**智能指针可以在适当时机自动释放分配的内存**。也就是说，**使用智能指针可以很好地避免“忘记释放内存而导致内存泄漏”问题出现**。由此可见，C++ 也逐渐开始支持垃圾回收机制了，尽管目前支持程度还有限。

> C++ 智能指针底层是采用**引用计数**的方式实现的。简单的理解，**智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。**

## shared_ptr智能指针

实际上，每种智能指针都是以类模板的方式实现的，shared_ptr 也不例外。shared_ptr<T>（其中 T 表示指针指向的具体数据类型）的定义位于`<memory>`头文件，并位于 std 命名空间中，因此在使用该类型指针时，程序中应包含如下 2 行代码：

```c++
#include <memory>
using namespace std;
```

值得一提的是，**和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。**

#### 1、shared_ptr智能指针的创建

shared_ptr<T> 类模板中，提供了多种实用的构造函数，这里给读者列举了几个常用的构造函数（以构建指向 int 类型数据的智能指针为例）。

1）通过如下 2 种方式，可以构造出 shared_ptr<T> 类型的空智能指针：

```c++
std::shared_ptr<int> p1;             //不传入任何实参
std::shared_ptr<int> p2(nullptr);    //传入空指针 nullptr
```

2）在构建 shared_ptr 智能指针，也可以明确其指向。例如：

```c++
std::shared_ptr<int> p3(new int(10));
```

由此，我们就成功构建了一个 shared_ptr 智能指针，其指向一块存有 10 这个 int 类型数据的堆内存空间。

同时，C++11 标准中还提供了 std::make_shared<T> 模板函数，其可以用于初始化 shared_ptr 智能指针，例如：

```c++
std::shared_ptr<int> p3 = std::make_shared<int>(10);
```

以上 2 种方式创建的 p3 是完全相同。

3）除此之外，shared_ptr<T> 模板还提供有相应的拷贝构造函数和移动构造函数，例如：

```c++
//调用拷贝构造函数
std::shared_ptr<int> p4(p3);//或者 std::shared_ptr<int> p4 = p3;
//调用移动构造函数
std::shared_ptr<int> p5(std::move(p4)); //或者 std::shared_ptr<int> p5 ==std::move(p4);
```

如上所示，p3 和 p4 都是 shared_ptr 类型的智能指针，因此可以用 p3 来初始化 p4，由于 p3 是左值，因此会调用拷贝构造函数。需要注意的是，如果 p3 为空智能指针，则 p4 也为空智能指针，其引用计数初始值为 0；反之，则表明 p4 和 p3 指向同一块堆内存，同时该堆空间的引用计数会加 1。

而对于 std::move(p4) 来说，该函数会强制将 p4 转换成对应的右值，因此初始化 p5 调用的是移动构造函数。另外和调用拷贝构造函数不同，用 std::move(p4) 初始化 p5，**会使得 p5 拥有了 p4 的堆内存，而 p4 则变成了空智能指针**。

注意，同一普通指针不能同时为多个 shared_ptr 对象赋值，否则会导致程序发生异常。例如：

```c++
int* ptr = new int;
std::shared_ptr<int> p1(ptr);
std::shared_ptr<int> p2(ptr);//错误
```

4）在初始化 shared_ptr 智能指针时，还可以自定义所指堆内存的释放规则，这样当堆内存的引用计数为 0 时，会优先调用我们自定义的释放规则。

在某些场景中，自定义释放规则是很有必要的。比如，对于申请的动态数组来说，**shared_ptr 指针默认的释放规则是不支持释放数组的**，只能自定义对应的释放规则，才能正确地释放申请的堆内存。

对于申请的动态数组，释放规则可以使用 C++11 标准中提供的 default_delete<T> 模板类，我们也可以自定义释放规则：

```c++
//指定 default_delete 作为释放规则
std::shared_ptr<int> p6(new int[10], std::default_delete<int[]>());
//自定义释放规则
void deleteInt(int*p) {
    delete []p;
}
//初始化智能指针，并自定义释放规则
std::shared_ptr<int> p7(new int[10], deleteInt);
```

实际上借助 lambda 表达式，我们还可以像如下这样初始化 p7，它们是完全相同的：

```c++
std::shared_ptr<int> p7(new int[10], [](int* p) {delete[]p; });
```

#### 2、shared_ptr<T>模板类提供的成员方法

为了方便用户使用 shared_ptr 智能指针，shared_ptr<T> 模板类还提供有一些实用的成员方法，它们各自的功能如表 1 所示。

| 成员方法名      | 功 能                                                        |
| --------------- | ------------------------------------------------------------ |
| operator=()     | 重载赋值号，使得同一类型的 shared_ptr 智能指针可以相互赋值。 |
| operator*()     | 重载 * 号，获取当前 shared_ptr 智能指针对象指向的数据。      |
| operator->()    | 重载 -> 号，当智能指针指向的数据类型为自定义的结构体时，通过 -> 运算符可以获取其内部的指定成员。 |
| swap()          | 交换 2 个相同类型 shared_ptr 智能指针的内容。                |
| reset()         | 当函数没有实参时，该函数会使当前 shared_ptr 所指堆内存的引用计数减 1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的 shared_ptr 对象会获得该存储空间的所有权，并且引用计数的初始值为 1。 |
| get()           | 获得 shared_ptr 对象内部包含的普通指针。                     |
| use_count()     | 返回同当前 shared_ptr 对象（包括它）指向相同的所有 shared_ptr 对象的数量。 |
| unique()        | 判断当前 shared_ptr 对象指向的堆内存，是否不再有其它 shared_ptr 对象再指向它。 |
| operator bool() | 判断当前 shared_ptr 对象是否为空智能指针，如果是空指针，返回 false；反之，返回 true。 |

>  除此之外，C++11 标准还支持同一类型的 shared_ptr 对象，或者 shared_ptr 和 nullptr 之间，进行 ==，!=，<，<=，>，>= 运算。



下面程序给大家演示了 shared_ptr 智能指针的基本用法，以及该模板类提供了一些成员方法的用法：

```c++
#include <iostream>
#include <memory>
using namespace std;
int main()
{
    //构建 2 个智能指针
    std::shared_ptr<int> p1(new int(10));
    std::shared_ptr<int> p2(p1);
    //输出 p2 指向的数据
    cout << *p2 << endl;
    p1.reset();//引用计数减 1,p1为空指针
    if (p1) {
        cout << "p1 不为空" << endl;
    }
    else {
        cout << "p1 为空" << endl;
    }
    //以上操作，并不会影响 p2
    cout << *p2 << endl;
    //判断当前和 p2 同指向的智能指针有多少个
    cout << p2.use_count() << endl;
    return 0;
}
```

程序执行结果为：

```
10
p1 为空
10
1
```





# 25. C++11 unique_ptr智能指针

作为智能指针的一种，unique_ptr 指针自然也具备“在适当时机自动释放堆内存空间”的能力。和 shared_ptr 指针最大的不同之处在于，unique_ptr 指针指向的堆内存无法同其它 unique_ptr 共享，也就是说，每个 unique_ptr 指针都独自拥有对其所指堆内存空间的所有权。

> 这也就意味着，每个 unique_ptr 指针指向的堆内存空间的引用计数，都只能为 1，一旦该 unique_ptr 指针放弃对所指堆内存空间的所有权，则该空间会被立即释放回收。

unique_ptr 智能指针是以模板类的形式提供的，unique_ptr<T>（T 为指针所指数据的类型）定义在`<memory>`头文件，并位于 std 命名空间中。因此，要想使用 unique_ptr 类型指针，程序中应首先包含如下 2 条语句：

```c++
#include <memory>
using namespace std;
```

## unique_ptr智能指针的创建

考虑到不同实际场景的需要，unique_ptr<T> 模板类提供了多个实用的构造函数，这里给读者列举了几种常用的构造 unique_ptr 智能指针的方式。

1）通过以下 2 种方式，可以创建出空的 unique_ptr 指针：

```c++
std::unique_ptr<int> p1();
std::unique_ptr<int> p2(nullptr);
```



2）创建 unique_ptr 指针的同时，也可以明确其指向。例如：

```c++
std::unique_ptr<int> p3(new int);
```

由此就创建出了一个 p3 智能指针，其指向的是可容纳 1 个整数的堆存储空间。

> 和可以用 make_shared<T>() 模板函数初始化 shared_ptr 指针不同，C++11 标准中并没有为 unique_ptr 类型指针添加类似的模板函数。



3） 基于 unique_ptr 类型指针不共享各自拥有的堆内存，因此 C++11 标准中的 unique_ptr 模板类没有提供拷贝构造函数，只提供了移动构造函数。例如：

```c++
std::unique_ptr<int> p4(new int);
std::unique_ptr<int> p5(p4);//错误，堆内存不共享
std::unique_ptr<int> p5(std::move(p4));//正确，调用移动构造函数
```

值得一提的是，对于调用移动构造函数的 p4 和 p5 来说，p5 将获取 p4 所指堆空间的所有权，而 p4 将变成空指针（nullptr）。

4）默认情况下，unique_ptr 指针采用 std::default_delete<T> 方法释放堆内存。当然，我们也可以自定义符合实际场景的释放规则。值得一提的是，和 shared_ptr 指针不同，**为 unique_ptr 自定义释放规则，只能采用函数对象的方式**。例如：

```c++
//自定义的释放规则
struct myDel
{
    void operator()(int *p) {
        delete p;
    }
};
std::unique_ptr<int, myDel> p6(new int);
//std::unique_ptr<int, myDel> p6(new int, myDel());
```

## unique_ptr<T>模板类提供的成员方法

为了方便用户使用 unique_ptr 智能指针，unique_ptr<T> 模板类还提供有一些实用的成员方法，它们各自的功能如表 1 所示。



| 成员函数名      | 功 能                                                        |
| --------------- | ------------------------------------------------------------ |
| operator*()     | 获取当前 unique_ptr 指针指向的数据。                         |
| operator->()    | 重载 -> 号，当智能指针指向的数据类型为自定义的结构体时，通过 -> 运算符可以获取其内部的指定成员。 |
| operator =()    | 重载了 = 赋值号，从而可以将 nullptr 或者一个右值 unique_ptr 指针直接赋值给当前同类型的 unique_ptr 指针。 |
| operator []()   | 重载了 [] 运算符，当 unique_ptr 指针指向一个数组时，可以直接通过 [] 获取指定下标位置处的数据。 |
| get()           | 获取当前 unique_ptr 指针内部包含的普通指针。                 |
| get_deleter()   | 获取当前 unique_ptr 指针释放堆内存空间所用的规则。           |
| operator bool() | unique_ptr 指针可直接作为 if 语句的判断条件，以判断该指针是否为空，如果为空，则为 false；反之为 true。 |
| release()       | 释放当前 unique_ptr 指针对所指堆内存的所有权，但该存储空间并不会被销毁。 |
| reset(p)        | 其中 p 表示一个普通指针，如果 p 为 nullptr，则当前 unique_ptr 也变成空指针；反之，则该函数会释放当前 unique_ptr 指针指向的堆内存（如果有），然后获取 p 所指堆内存的所有权（p 为 nullptr）。 |
| swap(x)         | 交换当前 unique_ptr 指针和同类型的 x 指针。                  |

> 除此之外，C++11标准还支持同类型的 unique_ptr 指针之间，以及 unique_ptr 和 nullptr 之间，做 ==，!=，<，<=，>，>= 运算。


下面程序给大家演示了 unique_ptr 智能指针的基本用法，以及该模板类提供了一些成员方法的用法：

```c++
#include <iostream>
#include <memory>
using namespace std;
int main()
{
    std::unique_ptr<int> p5(new int);
    *p5 = 10;
    // p 接收 p5 释放的堆内存
    int * p = p5.release();
    cout << *p << endl;
    //判断 p5 是否为空指针
    if (p5) {
        cout << "p5 is not nullptr" << endl;
    }
    else {
        cout << "p5 is nullptr" << endl;
    }
    std::unique_ptr<int> p6;
    //p6 获取 p 的所有权
    p6.reset(p);
    cout << *p6 << endl;;
    return 0;
}
```

程序执行结果为：

```
10
p5 is nullptr
10
```





# 26. C++11 weak_ptr智能指针

## C++11 weak_ptr智能指针

和 shared_ptr、unique_ptr 类型指针一样，weak_ptr 智能指针也是以模板类的方式实现的。weak_ptr<T>（ T 为指针所指数据的类型）定义在`<memory>`头文件，并位于 std 命名空间中。因此，要想使用 weak_ptr 类型指针，程序中应首先包含如下 2 条语句：

```c++
#include <memory>
using namespace std;
```

需要注意的是，C++11标准虽然将 weak_ptr 定位为智能指针的一种，但该类型指针通常不单独使用（没有实际用处），只能和 shared_ptr 类型指针搭配使用。甚至于，我们可以将 weak_ptr 类型指针**视为 shared_ptr 指针的一种辅助工具**，借助 weak_ptr 类型指针， 我们可以获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、shared_ptr 指针指向的堆内存是否已经被释放等等。

需要注意的是，当 weak_ptr 类型指针的指向和某一 shared_ptr 指针相同时，weak_ptr 指针并不会使所指堆内存的引用计数加 1；同样，当 weak_ptr 指针被释放时，之前所指堆内存的引用计数也不会因此而减 1。也就是说，**weak_ptr 类型指针并不会影响所指堆内存空间的引用计数**。

除此之外，weak_ptr<T> 模板类中没有重载 * 和 -> 运算符，这也就意味着，**weak_ptr 类型指针只能访问所指的堆内存，而无法修改它**。

#### 1、weak_ptr指针的创建

创建一个 weak_ptr 指针，有以下 3 种方式：
1）可以创建一个空 weak_ptr 指针，例如：

```c++
std::weak_ptr<int> wp1;
```

2）凭借已有的 weak_ptr 指针，可以创建一个新的 weak_ptr 指针，例如：

```c++
std::weak_ptr<int> wp2 (wp1);
```

若 wp1 为空指针，则 wp2 也为空指针；反之，如果 wp1 指向某一 shared_ptr 指针拥有的堆内存，则 wp2 也指向该块存储空间（可以访问，但无所有权）。

3）weak_ptr 指针更常用于指向某一 shared_ptr 指针拥有的堆内存，因为在构建 weak_ptr 指针对象时，可以利用已有的 shared_ptr 指针为其初始化。例如：

```c++
std::shared_ptr<int> sp (new int);
std::weak_ptr<int> wp3 (sp);
```

由此，wp3 指针和 sp 指针有相同的指针。再次强调，weak_ptr 类型指针不会导致堆内存空间的引用计数增加或减少。

#### 2) weak_ptr模板类提供的成员方法

和 shared_ptr<T>、unique_ptr<T> 相比，weak_ptr<T> 模板类提供的成员方法不多，表 1 罗列了常用的成员方法及各自的功能。

| 成员方法    | 功 能                                                        |
| ----------- | ------------------------------------------------------------ |
| operator=() | 重载 = 赋值运算符，是的 weak_ptr 指针可以直接被 weak_ptr 或者 shared_ptr 类型指针赋值。 |
| swap(x)     | 其中 x 表示一个同类型的 weak_ptr 类型指针，该函数可以互换 2 个同类型 weak_ptr 指针的内容。 |
| reset()     | 将当前 weak_ptr 指针置为空指针。                             |
| use_count() | 查看指向和当前 weak_ptr 指针相同的 shared_ptr 指针的数量。   |
| expired()   | 判断当前 weak_ptr 指针为否过期（指针为空，或者指向的堆内存已经被释放）。 |
| lock()      | 如果当前 weak_ptr 已经过期，则该函数会返回一个空的 shared_ptr 指针；反之，该函数返回一个和当前 weak_ptr 指向相同的 shared_ptr 指针。 |

> 再次强调，weak_ptr<T> 模板类没有重载 * 和 -> 运算符，因此 weak_ptr 类型指针只能访问某一 shared_ptr 指针指向的堆内存空间，无法对其进行修改。

下面的样例演示了 weak_ptr 指针以及表 1 中部分成员方法的基本用法：

```c++
#include <iostream>
#include <memory>
using namespace std;
int main()
{
    std::shared_ptr<int> sp1(new int(10));
    std::shared_ptr<int> sp2(sp1);
    std::weak_ptr<int> wp(sp2);
    //输出和 wp 同指向的 shared_ptr 类型指针的数量
    cout << wp.use_count() << endl;
    //释放 sp2
    sp2.reset();
    cout << wp.use_count() << endl;
    //借助 lock() 函数，返回一个和 wp 同指向的 shared_ptr 类型指针，获取其存储的数据
    cout << *(wp.lock()) << endl;
    return 0;
}
```

程序执行结果为：

```
2
1
10
```

